<html>
    <head>
    <script type="text/javascript" src="/assets/js/md5_backup.js"></script>
    <script type="text/javascript" src="/assets/js/digest-fetch-src.js"></script>
    </head>
    <body>
        <img id="image" width="640" height="480"/>
        <canvas id="canvas" width="640" heigth="480"></canvas>
        <script>
            // The mjpeg url.
            const THETA_IP_BOS = "192.168.1.27";
            const THETA_IP_ROC = "192.168.50.227";
            const CORS_ANYWHERE = "http://0.0.0.0:8080";
            const THETA_USER = "THETAYL00164391";
            const THETA_PASS = "00164391";
            
            const endpoint = "/osc/commands/execute";
            const url = CORS_ANYWHERE + "/" + THETA_IP_BOS + endpoint;
            const postData = { name: "camera.getLivePreview" };
            
            const SOI = new Uint8Array(2);
            SOI[0] = 0xFF;
            SOI[1] = 0xD8;
            const CONTENT_LENGTH = 'Content-Length';
            const TYPE_JPEG = 'image/jpeg';

            // Use digest fetch
            const digestOptions = {
              cnonceSize: 16,  // length of cnonce, default: 32
              logger: console, // logger for debug, default: none
              algorithm: 'MD5' // only 'MD5' is supported now
            }
            const client = new DigestClient(THETA_USER, THETA_PASS, digestOptions) 

            client.fetch(url, {
                method: 'POST',
                body: JSON.stringify(postData),
                headers: {
                    'Content-Type': 'application/json'
                }
            }).then(response => {
                if (!response.ok) {
                    throw Error(response.status+' '+response.statusText)
                }

                if (!response.body) {
                    throw Error('ReadableStream not yet supported in this browser.')
                }
                
                const reader = response.body.getReader();

                let headers = '';
                let contentLength = -1;
                let imageBuffer = null;
                let bytesRead = 0;


                // calculating fps. This is pretty lame. Should probably implement a floating window function.
                let frames = 0;
                
                setInterval(() => {
                    console.log("fps : " + frames);
                    frames = 0;
                }, 1000) 


                const read = () => {

                    reader.read().then(({done, value}) => {
                        if (done) {
                            controller.close();
                            return;
                        }
                        
                        for (let index =0; index < value.length; index++) {
                            
                            // we've found start of the frame. Everything we've read till now is the header.
                            if (value[index] === SOI[0] && value[index+1] === SOI[1]) {
                                contentLength = getLength(headers);
                                imageBuffer = new Uint8Array(new ArrayBuffer(contentLength));
                            }
                            // we're still reading the header.
                            if (contentLength <= 0) {
                                headers += String.fromCharCode(value[index]);
                            }
                            // we're now reading the jpeg. 
                            else if (bytesRead < contentLength){
                                imageBuffer[bytesRead++] = value[index];
                            }
                            // we're done reading the jpeg. Time to render it. 
                            else {
                                // console.log("jpeg read with bytes : " + bytesRead);
                                document.getElementById('image').src = URL.createObjectURL(new Blob([imageBuffer], {type: TYPE_JPEG}));
                                frames++;
                                contentLength = 0;
                                bytesRead = 0;
                                headers = '';
                            }
                        }

                        read();
                    }).catch(error => {
                        console.error(error);
                    })
                }
                
                read();
                
            }).catch(error => {
                console.error(error);
            })

            const getLength = (headers) => {
                let contentLength = -1;
                headers.split('\n').forEach((header, _) => {
                    const pair = header.split(':');
                    if (pair[0] === CONTENT_LENGTH) {
                    contentLength = pair[1];
                    }
                })
                return contentLength;
            };

        </script>
    </body>
</html>

